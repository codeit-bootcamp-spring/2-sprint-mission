클래스로 객체를 추상화한거를 데이터 형태를 표현, 정보 표현 -> Entity (데이터 표현?)
Entity에 객체(User, Channel, Mess)의 데이터를 관리하는 역할(서비스) (생성, 삭제, 조회) -> 서비스 (데이터 활용한 "기능" 제공)
 즉, 서비스는 객체를 다루기 위한 기능 CRUD 제공하는 역할

"사람 정보"와 "사람 관리 기능"을 분리
데이터를 다루는 방식과 책임을 분리

서비스 레벨에서 제공 받아야하는건 이름, 서비스를 통해서 유저 객체를 다 다룸.
서비스를 통해서 객체 생성. 그래서 인터페이스가 있는 것.
유저의 데이터와 데이터를 활용하는것 구분.

-----------
비즈니스 로직(유효성 검사, 등), 저장 로직 (CRUD)

FileInputStream fis = new FileInputStream(file) // 이미 존재하는 파일 읽어오기
FileOutputStream fos = new FileOutputStream(file) // 파일 생성, 쓰기

역할
ObjectOutputStream(fileName) : 자바 객체를 스트림 형태로 변환 (그래야 바이트 단위로 변환 가능)
writeObject(data): 스트림 형태의 객체를 → 바이트 스트림 변환 후 파일에 저장 (직렬화)
ObjectInputStream(fileName) : 파일에서 바이트 데이터를 통째로 읽어옴 (아직 객체 아니고, 스트림 형태의 바이트 데이터)
readObject() : 바이트 데이터를 실제 자바 객체로 변환해서 읽는다 (역직렬화)

serialVersionUID란?	-> 직렬화된 객체의 버전을 식별하는 ID
왜 필요함? ->	클래스가 변경되어도 예전 데이터를 호환 가능하게 하려고
없으면 어떻게 됨? -> 자동 생성되는데, 클래스가 변경되면 ID가 바뀌어 역직렬화 오류 발생 가능 ❌
해결 방법 ->	private static final long serialVersionUID = 1L; 명시적으로 추가! -> 클래스마다 고유 번호 -> 달라야함.

--------------

객체 클래스 -> 설계도로써 도메인 데이터(상태, 속성) 표현 -> 데이터 관리 및 데이터(상태)(getter/setter) 변경 담당
서비스 -> 비즈니스 로직 처리 (유효성 검사, 트랜잭션 등) -> 기능 담당
레포지토리 -> 데이터 CRUD 저장 로직 담당 -> 데이터 조회/수정 담당

역할과 책임 분리!

--------------

[정리]
Entity 객체 -> 추상화한 객체의 속성(데이터, 멤버변수, 필드)의 "정보를 표현"함. 그리고 그 "정보들의 관리"를 책임짐.
Service 객체 → 추상화된 객체의 비즈니스 로직을 처리하고, "데이터를 가공하거나 조작"하는 역할을 함. (값 변경)
Repository 객체 → 데이터베이스와의 직접적인 "연동"을 담당하며, "Entity 객체의 저장, 조회, 수정, 삭제" 등의 "데이터 액세스"(올바른 접근인지 확인 후)를 관리함.

[비즈니스 흐름]
프론트 = 손님 (주문함)
Controller = 웨이터 (주방보조에게 주문내역 전달) (Http 요청 전달)

(Service(주방 보조) + Repository(쉐프) = 주방)
Service = 주문 내역 확인 후 쉐프에게 전달

Repository = 요리사 (실제 요리를 수행, 즉 DB에서 데이터 저장/조회) (CRUD)
Entity = 요리를 담는 그릇 / 완성된 요리 (데이터를 담는 객체)
Database = 레시피 (모든 데이터를 모아두는 저장 공간) (데이터 조회 및 저장, 수정, 삭제)

쉐프가 그릇에 손님의 요청사항에 따라 요리를 해서(비즈니스 로직), 담으면(엔터티), 그릇을 다시 주방보조에게 주고, 다시 웨이터에게 전달.
웨이터 Controller는 다시 요리 내용 손님에게 전달.


---------------

[Bean]
정의: Spring Bean은 Spring IoC 컨테이너에 의해 생성·관리되는 객체를 의미
사용 이유: 인터페이스와 구현체를 분리한 뒤, 구현체를 Bean으로 등록하면 스프링이 알아서 의존성 주입을 할 수 있게 됌. 그래서 Config 설정해줘야함.
정의(등록) 3가지 방법: 1. XML, 2. 어노테이션, 3. 자바 기반 설정
정의(등록)해주면 -> 스프링이 자동으로 객체를 생성해서 Ioc 컨테이너에 넣어줌. (알아서 관리해줌.)

질문 모아두기
1) Config 파일들 위치 맞는지?
2) bean 등록이 올바르게 됐는지
3) @bean (설정 클래스를 통한 명시 방법, 유지보수 장점) 등록과 @Service 등록을 동시에 하면 빈이 두번 등록되던데? 그럼 어떤게 더 나은건지? 와이?
4) getbean(안에 자바 클래스를 .class로 컴파일한 바이트코드 파일을 집어넣는것인데) 그럼,
-   <T> T getBean(java.lang.Class<T> requiredType) throws org.springframework.beans.BeansException; 이런거 어떻게 해석하는지 궁금. lang,Class<T> 뭔디...

5) PR을 모아서 하는게 맞는지? 커밋 하나하나마다 PR하는게 맞는지?
6) 컴파일 시점과 런타임 시점? (이건 따로 알아보기)
7) ObjectOutputStream이 open(), close()되면 내용일 파일에 작성되는데, 그러면 프로그램이 종료돼야 파일이 생성됌, 그래서 flush()를 추가하면, 그러면 안 좋은걸로 알고 있긴한데,
   근데 사용을 안 하면 프로그램이 종료될때까지 close()가 실행 안돼서 기록을 안 하고 버퍼(공간)? 스트림 버퍼?에 내용이 남아있는것 아닌가? 실시간 기록이 좋은거 아닌가?
8) 프로그램을 실행할때마다, 같은 공지방 채널이든 메세지든 다 새로운 파일로 생성되는데, 그럼 싱글톤이 아니게 되는것 아닌가? 싱글톤은 프로그램이 유지되는 상태에서 해당하는 것인지?
   그렇다면, 실무에서는 프로그램이 한번 배포되면 평생 꺼지면 안 되는건지? 만약에 한번이라도 꺼지면 기록된 내용들이 중복 저장되거나 그러는건지? 아니면 지금 연습이라 ID를 랜덤으로 생성해서 그런건지?
   아니면 DB에 저장하면 다른지?

9) 안정성은 조금 떨어질 수 있지만, enum 대신 그냥 String을 써도 되는 것이 맞겠지? 단지 enum의 장점이 있을뿐.



-------------
Spring 핵심 개념 이해하기 (PR 내용 포함하기)
[ ] JavaApplication과 DiscodeitApplication에서 Service를 초기화하는 방식의 차이에 대해 다음의 키워드를 중심으로 정리해보세요.

IoC Container - 빈의 생성, 생명주기, 의존석을 관리해주는 컨테이너 (Spring Context)
Dependency Injection (DI) - 객체 간 의존 관계를 코드로 들어내는 대신, 스프링 프레임워크가 자동으로 의존성 주입해주는 방식
Bean - 컨테이너 안에서 관리되는 "객체"

기존 방식:
- new 키워드로 직접 객체 생성
- 객체 간 의존성을 직접 설정하는 방식 (코드로)
- 개발자가 직접 객체의 생성 및 의존성 주입을 관리해야 합니다.
- IoC 원칙이 적용되지 않습니다. (직접 객체를 관리하고 생성)

개선된 방식:
- 스프링에게 생성과 관리를 맡김
- 직접 생성하지 않고, 대신 스프링(IoC 컨테이너)에 의해 자동 생성된 객체(Bean)을 가져와 사용합니다. (@Configuration @Bean으로 빈이라는걸 알려줘야함(정의))
- 객체의 생성, 생명주기 관리, 의존선 관리를 직접 하지 않고, Spring(IoC 컨테이너)에 맡김으로써 제어의 역전(IoC, Inversion of Control)이 일어납니다.
(내가 제어하던걸 스프링에게 넘어가는 현상)


